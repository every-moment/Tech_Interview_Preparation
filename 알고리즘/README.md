# 알고리즘   

## Graph    
그래프의 정의      
 - 그래프는 어떤 자료나 개념을 표현하는 정점들의 집합 V와 이들을 연결하는 간선들의 집합 E로 구성된 자료구조이다      
</br>

그래프의 종류
 - 간선의 형태로 분류      
     - 방향 그래프(directed graph): 각 간선이 방향이라는 속성을 갖는다. 두 정점 u, v가 있을 때 u에서 v로 가는 간선과 v에서 u로 가는 간선은 다른 간선이다. 도로망에서 일방 통행이 한 예      
     - 무향 그래프(undirected graph): 간선에 방향이 없는 그래프      
     - 가중치 그래프(weighted graph): 각 간선에 가중치(weight)라 불리는 실수 속성을 부여. 두 도시 사이의 거리가 한 예      
 - 그래프의 형태로 분류      
     - 다중 그래프(multigraph): 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프. 도로망에서 두 지점을 잇는 두 개 이상의 도로가 있을 수 있는 것이 한 예      
     - 단순 그래프(simple graph): 두 정점 사이에 최대 한 개의 간선만 있는 그래프       
     - 이분 그래프(bipartite graph): 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만든 그래프      
</br>

그래프의 표현 방법
 - 인접 리스트
    - 각 정점마다 하나의 연결 리스트를 갖고 이 연결리스트에 해당 정점에서 나가는 간선 정보의 목록을 저장한다     
    - 두 정점이 연결되어 있는 지를 알기 위해서는 연결리스트를 일일이 뒤져야 하기 때문에 연산의 속도가 느리다      
 - 인접 행렬  
    - 정점의 집합 크기 V에 대해 V*V 크기의 행렬 즉, 2차원 배열을 이용해 그래프의 간선 정보를 저장한다      
    - 행렬을 adj라 하면 adj[i][j]는 정점 i에서 정점 j로 가는 간선이 있는지를 나타낸다      
    - 가중치 그래프라면 adj[i][j]에 가중치 값을 저장한다      
</br>    

 - 인접 리스트 vs 인접 행렬
    - 인접 행렬의 가장 큰 장점은 정점의 번호 u, v가 주어졌을 때 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인할 수 있다는 점      
    - 인접 리스트의 경우 간선 (u, v)가 존재하는지 확인하기 위해서는 연결리스트 adj[u]를 처음 부터 읽어가면서 일일이 확인해야 한다      
    - 반면, 인접 행렬은 V*V 크기의 2차원 배열을 사용하기 때문에, 실제 간선의 개수와 관계없이 항상 O(V^2)크기의 공간을 사용한다는 문제점이 있다      
    - 인접 리스트는 V개의 연결리스트에 실제 간선 수 만큼 원소가 들어 있으므로 O(V+E)크기의 공간만을 사용한다      
    - 따라서, 희소 그래프에 대해서는 인접 리스트를, 밀집 그래프에 대해서는 인접 행렬을 사용하는 것이 유리하다      
    - 희소그래프: 간선의 수가 V^2에 비해 훨씬 적은 그래프      
    - 밀집 그래프: 간선의 수가 V^2에 거의 비례하는 그래프      
</br>
     
## DFS vs BFS    
</br>

DFS
 - 임의의 노드에서 시작하여 다음 분기(Branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식      
 - DFS의 중요한 특성은 더 따라갈 간선이 없을 경우 이전으로 돌아간다는 점      
 - 이것을 구현하기 위해서는 지금까지 거쳐온 정점들을 모두 저장해 둬야 한다. 재귀 호출 혹은 스택을 이용하면 이와 같은 일을 간단하게 할 수 있다.      
 - 인접 리스트로 구현된 그래프에서 DFS의 시간복잡도: O(V+E)
    - dfs 함수는 한 정점마다 정확하게 한 번 호출 되므로 V번 호출, dfs 함수의 수행 시간은 모든 인접 간선을 검사하는 for문에 의해 지배되는데, 모든 정점에 대해 dfs 함수를 수행하고 나면 모든 간선을 정확히 한 번(방향 그래프) 혹은 두 번(무향 그래프) 확인함을 알 수 있다.            
 - 인접 행렬로 구현된 그래프에서 DFS의 시간복잡도: O(V^2)      
    - dfs 함수는 한 정점마다 정확하게 한 번 호출 되므로 V번 호출, dfs 함수 내부에서 다른 모든 정점을 순회하며 두 정점 사이에 간선이 있는가를 확인해야 하기 때문에 한 번의 실행에 O(V)가 든다. 따라서 전체 시간 복잡도는 O(V^2)      
 - 경로마다 특징을 저장해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못한다)      
</br>

BFS
 - 임의의 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점은 나중에 방문하는 방식      
 - 해당 노드의 주변부터 탐색해야 하기 때문에 큐를 사용하여 구현할 수 있다.      
 - 그래프의 구조에 관련된 다양한 문제를 푸는 데 사용되는 DFS와 달리, BFS는 대개 딱 하나의 용도로 사용된다. 바로 그래프에서의 최단 경로를 문제를 푸는 것이다.      
 - 왜냐하면 DFS로 경로를 탐색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, BFS는 현재 노드에서 가까운 곳부터 찾기 때문에 경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문    
</br>

## 정렬

### 버블정렬

 - 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 swap을 하며 정렬하는 알고리즘.    
 - 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, ... 이런 식으로 마지막 - 1 번째 원소와 마지막 원소를 비교하여 조건에 맞지 않으면 swap    
 - 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.    
 - 시간복잡도: O(N^2) -> (n-1)+(n-2)+(n-3)+ ... +2+1 => n(n-1)/2 이기 때문.   
 - 장점
    - 구현이 간단함
    - 소스가 직관적   
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않음.    
    - 안정 정렬.   
 - 단점
    - 항상 O(n^2)으로 느림.    
    - 역순으로 정렬된 배열을 정렬할 때 swap을 매번 해야하기 때문에 가장 느림.(반대로 이미 정렬되어 있는 배열을 정렬할 때는 swap이 필요하지 않아서 빠르게 동작).        
</br>

* 버블정렬 최적화 *         
 - 1. 특정 턴에서 swap이 더 이상 발생하지 않으면 정렬을 종료한다
    - swap이 발생하지 않았단 것은 정렬이 완료되었음을 의미하기 때문
 - 2. 뒷 부분의 일부 원소들이 이미 정렬된 경우
    - 최종적으로 swap이 된 위치를 파악하여 다음 턴에서는 그 위치까지만 검사하도록 진행

### 선택정렬

 - 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘     
 - 배열에서 해당 자리를 선택하고 그 자리에 오는 값을 찾음.    
 - 주어진 배열에서 최솟값을 찾음
 - 이 최솟값을 배열의 맨 앞의 원소와 swap
 - 두 번째 위치부터 다시 시작한다.   
 - 시간복잡도: O(N^2) -> (n-1)+(n-2)+(n-3)+ ... +2+1 => n(n-1)/2 이기 때문.    
 - 장점
    - 버블정렬과 마찬가지로 구현이 간단함.   
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않음.    
    - 비교 횟수는 많지만 swap 횟수는 버블정렬보다 적어서 많은 교환이 일어나야 하는 배열의 상태에서는 버블정렬보다 퍼포먼스가 좋음.   
 - 단점
    - 항상 O(n^2)으로 느림.    
    - 불안정 정렬.   
</br>
    
### 삽입정렬

 - 2번째 원소부터 시작하여 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 정한 후, 원소들을 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬.   
 - 시간복잡도
    - 최악(역으로 정렬 되어 있음): O(N^2) -> 1+2+ ... + (n-3)+(n-2)+(n-1) => n(n-1)/2 이기 때문.    
    - 최선(정렬 되어 있음): O(n) -> 원소당 한번씩만 비교하면 되기 떄문.    
 - 버블정렬, 선택정렬보다 빠름.   
 - 장점
    - 선택 정렬이나 버블 정렬에 비하여 상대적으로 빠름.    
    - 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적.    
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않음.    
    - 안정 정렬.   
 - 단점
    - 평균과 최악의 시간복잡도가 O(n^2)으로 느림.   
</br>

### 퀵정렬

 - 분할 정복 방법을 이용해서 배열을 정렬한다.   
 - 정렬 로직
    - 배열의 원소 가운데 하나를 고른다. 이렇게 고른 원소를 피벗(pivot)이라 한다.    
    - 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다(정렬이 된 상태이기 때문).   
    - 분할 된 두 개의 배열에 대해 재귀적으로 이 과정을 반복한다.   
 - 장점
    - 먼 거리의 데이터를 교환할 뿐만 아니라, 한번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(N logN)을 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠름.   
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않음.    
 - 단점
    - 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행 시간이 더 많이 걸림.   
    - 불안정 정렬.   
</br>  
 
### 병합정렬

 - 분할 정복 방법을 이용해서 배열을 정렬한다.   
 - 병합의 대상이 되는 두 영역이 각 영역에 대해서 정렬이 되어있기 때문에 단순히 두 영역을 순차적으로 비교하면서 정렬할 수가 있다.    
 - 병합정렬은 순차적인 비교로 정렬을 진행하므로, LinkedList의 정렬이 필요할 때 사용하면 효율적 - > 퀵정렬은, 순차 접근이 아닌 임의 접근이기 때문에 인덱스로 접근할 수 없는 LinkedList에서는 비효율적이다.      
 - 퀵 정렬과의 차이점   
    - 퀵정렬 : 우선 피벗을 통해 정렬(partition) → 영역을 쪼갬(quickSort)     
    - 병합정렬 : 영역을 쪼갤 수 있을 만큼 쪼갬(mergeSort) → 정렬(merge)    
 - 장점
    - 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다 -> O(N logN).    
    - 크기가 큰 레코드를 정렬한 경우, LinkedList를 사용한다면 병합 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적.   
    - 안정 정렬
 - 단점
    - 공간이 많이 필요하다는 점. 정렬을 하기 위해서는 데이터 전체 크기만한 메모리가 더 필요 -> 메모리 낭비를 초래.   
</br>
    
### 힙정렬

 - 완전 이진 트리를 기본으로 하는 힙(Heap) 자료구조를 기반으로한 정렬 방식 -> 완전 이진 트리: 삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리.    
 - 정렬 로직
    - 오름차순으로 정렬하는 경우.   
    - 최대 힙을 구성 -> 모든 원소(n)에 대해서 Heapify(O(logn))을 수행 -> O(nlogn)  
    - 힙 루트에 가장 큰 값이 존재.
    - 루트와 힙의 가장 마지막 값(배열의 경우 가장 마지막에 있음)을 swap -> 마지막 값은 정렬이 이루어 졌음     
    - 다시 Heapify 후 루트와 힙의 가장 마지막 값(정렬 된 값들 제외)을 다시 바꾸면서 반복
 - 퀵 정렬과 병합 정렬이 더욱 성능이 좋기 때문에 힙 정렬의 사용 빈도가 높지는 않다.   
 - 장점
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않음.    
    - 항상 O(nlogn)을 보장.   
 - 단점
    - 병합정렬과 퀵정렬에 비해 평균적으로 느리다.    
    - 불안정 정렬.   
</br>

