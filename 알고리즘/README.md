# 알고리즘   

## Graph    
그래프의 정의      
 - 그래프는 어떤 자료나 개념을 표현하는 정점들의 집합 V와 이들을 연결하는 간선들의 집합 E로 구성된 자료구조이다      
</br>

그래프의 종류
 - 간선의 형태로 분류      
     - 방향 그래프(directed graph): 각 간선이 방향이라는 속성을 갖는다. 두 정점 u, v가 있을 때 u에서 v로 가는 간선과 v에서 u로 가는 간선은 다른 간선이다. 도로망에서 일방 통행이 한 예      
     - 무향 그래프(undirected graph): 간선에 방향이 없는 그래프      
     - 가중치 그래프(weighted graph): 각 간선에 가중치(weight)라 불리는 실수 속성을 부여. 두 도시 사이의 거리가 한 예      
 - 그래프의 형태로 분류      
     - 다중 그래프(multigraph): 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프. 도로망에서 두 지점을 잇는 두 개 이상의 도로가 있을 수 있는 것이 한 예      
     - 단순 그래프(simple graph): 두 정점 사이에 최대 한 개의 간선만 있는 그래프       
     - 이분 그래프(bipartite graph): 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만든 그래프      
</br>

그래프의 표현 방법
 - 인접 리스트
    - 각 정점마다 하나의 연결 리스트를 갖고 이 연결리스트에 해당 정점에서 나가는 간선 정보의 목록을 저장한다     
    - 두 정점이 연결되어 있는 지를 알기 위해서는 연결리스트를 일일이 뒤져야 하기 때문에 연산의 속도가 느리다      
 - 인접 행렬  
    - 정점의 집합 크기 V에 대해 V*V 크기의 행렬 즉, 2차원 배열을 이용해 그래프의 간선 정보를 저장한다      
    - 행렬을 adj라 하면 adj[i][j]는 정점 i에서 정점 j로 가는 간선이 있는지를 나타낸다      
    - 가중치 그래프라면 adj[i][j]에 가중치 값을 저장한다      
</br>    

 - 인접 리스트 vs 인접 행렬
    - 인접 행렬의 가장 큰 장점은 정점의 번호 u, v가 주어졌을 때 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인할 수 있다는 점      
    - 인접 리스트의 경우 간선 (u, v)가 존재하는지 확인하기 위해서는 연결리스트 adj[u]를 처음 부터 읽어가면서 일일이 확인해야 한다      
    - 반면, 인접 행렬은 V*V 크기의 2차원 배열을 사용하기 때문에, 실제 간선의 개수와 관계없이 항상 O(V^2)크기의 공간을 사용한다는 문제점이 있다      
    - 인접 리스트는 V개의 연결리스트에 실제 간선 수 만큼 원소가 들어 있으므로 O(V+E)크기의 공간만을 사용한다      
    - 따라서, 희소 그래프에 대해서는 인접 리스트를, 밀집 그래프에 대해서는 인접 행렬을 사용하는 것이 유리하다      
    - 희소그래프: 간선의 수가 V^2에 비해 훨씬 적은 그래프      
    - 밀집 그래프: 간선의 수가 V^2에 거의 비례하는 그래프      
</br>
     
## DFS vs BFS    
</br>

DFS
 - 임의의 노드에서 시작하여 다음 분기(Branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식      
 - DFS의 중요한 특성은 더 따라갈 간선이 없을 경우 이전으로 돌아간다는 점      
 - 이것을 구현하기 위해서는 지금까지 거쳐온 정점들을 모두 저장해 둬야 한다. 재귀 호출 혹은 스택을 이용하면 이와 같은 일을 간단하게 할 수 있다.      
 - 인접 리스트로 구현된 그래프에서 DFS의 시간복잡도: O(V+E)
    - dfs 함수는 한 정점마다 정확하게 한 번 호출 되므로 V번 호출, dfs 함수의 수행 시간은 모든 인접 간선을 검사하는 for문에 의해 지배되는데, 모든 정점에 대해 dfs 함수를 수행하고 나면 모든 간선을 정확히 한 번(방향 그래프) 혹은 두 번(무향 그래프) 확인함을 알 수 있다.            
 - 인접 행렬로 구현된 그래프에서 DFS의 시간복잡도: O(V^2)      
    - dfs 함수는 한 정점마다 정확하게 한 번 호출 되므로 V번 호출, dfs 함수 내부에서 다른 모든 정점을 순회하며 두 정점 사이에 간선이 있는가를 확인해야 하기 때문에 한 번의 실행에 O(V)가 든다. 따라서 전체 시간 복잡도는 O(V^2)      
 - 경로마다 특징을 저장해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못한다)      
</br>

BFS
 - 임의의 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방법. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점은 나중에 방문하는 방식      
 - 해당 노드의 주변부터 탐색해야 하기 때문에 큐를 사용하여 구현할 수 있다.      
 - 그래프의 구조에 관련된 다양한 문제를 푸는 데 사용되는 DFS와 달리, BFS는 대개 딱 하나의 용도로 사용된다. 바로 그래프에서의 최단 경로를 문제를 푸는 것이다.      
 - 왜냐하면 DFS로 경로를 탐색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, BFS는 현재 노드에서 가까운 곳부터 찾기 때문에 경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문    
</br>
